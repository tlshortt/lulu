---
phase: 02-single-session-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/session/events.rs
  - src-tauri/src/session/cli.rs
  - src-tauri/src/commands/session.rs
  - src-tauri/src/db/session.rs
  - src-tauri/src/bin/lulu_test_cli.rs
  - src-tauri/tests/cli_ipc.rs
  - src-tauri/tests/single_session_core.rs
autonomous: true
must_haves:
  truths:
    - User can launch one named session with prompt and working directory
    - Session emits live structured events for message, thinking, tool_call, tool_result, status, and error
    - Session reaches one terminal state and that state is durable in SQLite
  artifacts:
    - path: src-tauri/src/commands/session.rs
      provides: spawn command with single terminal lifecycle reducer
    - path: src-tauri/src/session/cli.rs
      provides: stream-json normalization into typed session events
    - path: src-tauri/src/session/events.rs
      provides: typed payload contract including thinking and terminal statuses
    - path: src-tauri/src/db/session.rs
      provides: durable session status transitions
    - path: src-tauri/tests/single_session_core.rs
      provides: integration verification for launch, stream, and terminal persistence
  key_links:
    - from: src-tauri/src/session/cli.rs
      to: src-tauri/src/commands/session.rs
      via: mpsc::Sender<SessionEvent>
      pattern: spawn_with_events\(.*event_tx\)
    - from: src-tauri/src/commands/session.rs
      to: src-tauri/src/db/session.rs
      via: create/update session records in all terminal paths
      pattern: create_session\(|update_session_status\(
    - from: src-tauri/src/commands/session.rs
      to: session-event
      via: to_frontend_session_event payload mapping
      pattern: emit\("session-event"
---

<objective>
Harden backend single-session runtime so launch, live stream normalization, and terminal lifecycle persistence are deterministic.

Purpose: satisfy SESS-01 (single-session slice), OUT-01 event fidelity, and GIT-01 working-directory reliability before frontend finalization.
Output: canonical stream-json event normalization, idempotent terminal status handling, and fixture-backed backend tests.
</objective>

<execution_context>
@/Users/timothyshortt/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/timothyshortt/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-single-session-core/02-RESEARCH.md
@src-tauri/src/commands/session.rs
@src-tauri/src/session/cli.rs
@src-tauri/src/session/events.rs
@src-tauri/src/db/session.rs
</context>

<tasks>

<task type="auto">
  <name>Normalize Claude stream-json output into canonical typed session-event payloads</name>
  <files>src-tauri/src/session/events.rs, src-tauri/src/session/cli.rs, src-tauri/src/commands/session.rs</files>
  <action>Update CLI spawn flags and parser so `spawn_with_events` consumes real Claude `--output-format stream-json` frames and maps them into the internal typed payload contract (`message`, `thinking`, `tool_call`, `tool_result`, `status`, `error`). Keep `session-event` as the canonical output path; maintain legacy emits only as compatibility shims and do not add new behavior there. Ensure every emitted event includes stable `session_id`, monotonic `seq`, and timestamp metadata.</action>
  <verify>cd src-tauri && cargo test --test cli_ipc</verify>
  <done>Representative stream-json fixture lines are normalized into typed payloads and emitted through `session-event` in monotonically increasing sequence order.</done>
</task>

<task type="auto">
  <name>Implement idempotent terminal lifecycle reducer with durable DB updates</name>
  <files>src-tauri/src/commands/session.rs, src-tauri/src/db/session.rs</files>
  <action>Centralize terminal transitions in `spawn_session` so completion and failure update DB and emit frontend terminal status from one guarded path only. Validate working directory before spawn; when validation or spawn fails, avoid stale `running` records and return a clear error. Keep status vocabulary consistent (`running`, `completed`, `failed`, and existing explicit `killed` path) and prevent duplicate terminal emits from child poll + event loops.</action>
  <verify>cd src-tauri && cargo test --test single_session_core -- --nocapture</verify>
  <done>Each session transitions once to `completed` or `failed` (or `killed` on explicit kill), and `list_sessions`/`get_session` always reflect that final status after process exit.</done>
</task>

<task type="auto">
  <name>Add fixture-backed integration tests for launch, streaming, and terminal persistence</name>
  <files>src-tauri/src/bin/lulu_test_cli.rs, src-tauri/tests/cli_ipc.rs, src-tauri/tests/single_session_core.rs</files>
  <action>Extend fixture output to cover success and failure stream shapes (including thinking/tool events), then add/update integration tests that assert: launch with name/prompt/working_dir works, stream events are typed and ordered, terminal event is emitted once, and DB status is persisted to the same terminal state. Keep tests deterministic with bounded timeouts and no dependency on globally installed Claude CLI.</action>
  <verify>cd src-tauri && cargo test --test cli_ipc --test single_session_core</verify>
  <done>Backend integration tests prove single-session launch and live streaming contract correctness, plus durable terminal status persistence without duplicate terminal transitions.</done>
</task>

</tasks>

<verification>
Run `cd src-tauri && cargo test --test cli_ipc --test single_session_core` and confirm all tests pass with deterministic event ordering and one terminal transition per run.
</verification>

<success_criteria>
Backend launches one session with name/prompt/working dir, streams typed events in real time, and persists one terminal status (`completed` or `failed`) without app crash.
</success_criteria>

<output>
After completion, create `.planning/phases/02-single-session-core/02-single-session-core-01-SUMMARY.md`
</output>
