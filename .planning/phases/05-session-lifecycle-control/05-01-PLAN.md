---
phase: 05-session-lifecycle-control
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/db/mod.rs
  - src-tauri/src/db/session.rs
  - src-tauri/src/session/projection.rs
  - src-tauri/src/session/cli.rs
  - src-tauri/src/session/supervisor.rs
  - src-tauri/src/commands/session.rs
  - src-tauri/src/lib.rs
  - src-tauri/tests/multi_session_orchestration.rs
autonomous: true
must_haves:
  truths:
    - User can interrupt an in-progress session and backend transitions it to interrupted (not failed)
    - Interrupt performs one silent retry and surfaces a timeout error only after 10 seconds total
    - User can resume a completed or interrupted session in the same session row using Claude CLI native resume semantics
    - Lifecycle failures stay scoped to the target session and do not mutate unrelated session runtimes
  artifacts:
    - path: src-tauri/src/commands/session.rs
      provides: interrupt and resume tauri commands with backend-authoritative lifecycle transitions
    - path: src-tauri/src/session/supervisor.rs
      provides: per-session lifecycle operation gates, interrupt deadline handling, and terminal guard integration
    - path: src-tauri/src/session/cli.rs
      provides: CLI argument composition for native resume/continue flow with deterministic identity
    - path: src-tauri/src/db/session.rs
      provides: interrupted/resuming status persistence and same-row resume attempt metadata updates
    - path: src-tauri/src/session/projection.rs
      provides: explicit dashboard vocabulary mapping for Interrupted
    - path: src-tauri/tests/multi_session_orchestration.rs
      provides: regression coverage for interrupt/retry/deadline and per-session runtime isolation
  key_links:
    - from: src-tauri/src/commands/session.rs
      to: src-tauri/src/session/supervisor.rs
      via: interrupt command delegates retry/deadline lifecycle control to supervisor authority
      pattern: interrupt.*supervisor|retry|Duration::from_secs\(10\)
    - from: src-tauri/src/commands/session.rs
      to: src-tauri/src/session/cli.rs
      via: resume command composes CLI-native --resume/--continue invocation
      pattern: --resume|--continue|spawn.*resume
    - from: src-tauri/src/session/supervisor.rs
      to: src-tauri/src/db/session.rs
      via: guarded lifecycle transitions persist interrupted/resuming/running and attempt metadata on one session row
      pattern: update_session_status|transition_session_terminal|resume_count|active_run_id
---

<objective>
Implement backend lifecycle control for Phase 5 so interrupt and resume behaviors are authoritative, deterministic, and isolated per session.

Purpose: satisfy LIFE-01, LIFE-02, and LIFE-04 by making Rust runtime/state transitions enforce the locked interrupt contract and CLI-native resume flow.
Output: new lifecycle commands plus persistence/runtime wiring and integration tests for interrupt retry/deadline and resume correctness.
</objective>

<execution_context>
@/Users/timothyshortt/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/timothyshortt/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-session-lifecycle-control/05-CONTEXT.md
@.planning/phases/05-session-lifecycle-control/05-RESEARCH.md
@.planning/phases/03-multi-session-orchestration/03-multi-session-orchestration-02-SUMMARY.md
@.planning/phases/03-multi-session-orchestration/03-multi-session-orchestration-04-SUMMARY.md
@src-tauri/src/commands/session.rs
@src-tauri/src/session/supervisor.rs
@src-tauri/src/session/cli.rs
@src-tauri/src/db/session.rs
@src-tauri/src/session/projection.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add backend-authoritative interrupt and resume lifecycle transitions</name>
  <files>src-tauri/src/commands/session.rs, src-tauri/src/session/supervisor.rs, src-tauri/src/session/cli.rs, src-tauri/src/db/mod.rs, src-tauri/src/db/session.rs, src-tauri/src/session/projection.rs, src-tauri/src/lib.rs</files>
  <action>Implement `interrupt_session` and `resume_session` tauri commands and keep all lifecycle authority in Rust command/supervisor boundaries. Enforce locked interrupt behavior exactly: allow interrupt from running/in-progress states, transition target session to `interrupting`, perform one silent retry if the first stop attempt does not complete, and return a user-visible error only after a 10-second total deadline. On success persist `interrupted` status, keep one existing session row (no child-row lineage), and do not emit any separate timeline event dedicated to successful interrupt. Implement resume through Claude CLI native continuation flags (`--resume`/`--continue`) with deterministic session identity and same-row attempt metadata (`resume_count`, `active_run_id`, `last_resume_at`) so resumed output appends to existing history. Update projection vocabulary so `interrupted` projects as `Interrupted` (not `Failed`) while failure normalization remains unchanged for true failures.</action>
  <verify>npm run test:rust -- --test multi_session_orchestration</verify>
  <done>Backend exposes interrupt/resume lifecycle commands, persists interrupted/resume state in the existing session row, and honors the locked 10s retry/deadline behavior with backend-authoritative transitions.</done>
</task>

<task type="auto">
  <name>Task 2: Add integration regression coverage for interrupt deadline, resume, and isolation</name>
  <files>src-tauri/tests/multi_session_orchestration.rs, src-tauri/src/commands/session.rs, src-tauri/src/session/supervisor.rs</files>
  <action>Extend integration tests to prove lifecycle correctness: (1) interrupting one session transitions to `interrupted` without mutating sibling session runtime state, (2) a stuck interrupt path applies one silent retry and only fails after 10 seconds total, and (3) resuming a completed/interrupted session reuses the same session id/row and continues event streaming without duplicate terminal transitions. Add assertions that successful interrupt does not introduce an extra timeline-only event and that per-session operation gates prevent concurrent interrupt/resume races on the same session.</action>
  <verify>npm run test:rust -- --test multi_session_orchestration</verify>
  <done>Rust integration suite fails on interrupt/resume regressions and demonstrates session-scoped lifecycle isolation under mixed outcomes.</done>
</task>

</tasks>

<verification>
Run `npm run test:rust -- --test multi_session_orchestration` and confirm interrupt/retry/deadline plus same-row resume coverage passes.
</verification>

<success_criteria>
Backend lifecycle control is phase-ready: interrupted is a first-class persisted/projection status, interrupt honors the locked retry/deadline contract, resume uses CLI-native continuation on the same session row, and errors remain isolated per session runtime.
</success_criteria>

<output>
After completion, create `.planning/phases/05-session-lifecycle-control/05-session-lifecycle-control-01-SUMMARY.md`
</output>
