---
phase: 05-session-lifecycle-control
plan: 03
type: execute
wave: 3
depends_on:
  - 05-01
  - 05-02
files_modified:
  - src/lib/stores/sessions.ts
  - src/lib/components/NewSessionModal.svelte
  - src/lib/components/NewSessionModal.test.ts
  - src/lib/__tests__/sessions.spawn.test.ts
  - src-tauri/src/commands/session.rs
  - src-tauri/tests/multi_session_orchestration.rs
autonomous: true
gap_closure: true
must_haves:
  truths:
    - User can submit New Session and the app launches a session instead of stalling on the modal
    - If New Session launch fails, the modal shows a clear user-visible error explaining what failed and how to retry
    - A failed New Session launch does not block future retries and does not regress Phase 5 interrupt/resume behavior
  artifacts:
    - path: src/lib/stores/sessions.ts
      provides: bounded spawn invocation path with explicit error normalization and retry-safe cleanup
    - path: src/lib/components/NewSessionModal.svelte
      provides: clear launch failure feedback and stable retry UX on the New Session screen
    - path: src-tauri/src/commands/session.rs
      provides: spawn_session failure reasons propagated as actionable strings for frontend display
    - path: src/lib/components/NewSessionModal.test.ts
      provides: modal regressions for launch success, launch failure messaging, and retry behavior
    - path: src/lib/__tests__/sessions.spawn.test.ts
      provides: store-level regression coverage for spawn timeout and surfaced error contract
  key_links:
    - from: src/lib/components/NewSessionModal.svelte
      to: src/lib/stores/sessions.ts
      via: submit action calls spawnSession and renders returned failure message in visible error region
      pattern: handleSubmit|spawnSession|error
    - from: src/lib/stores/sessions.ts
      to: src-tauri/src/commands/session.rs
      via: invoke("spawn_session") failure/timeout is normalized into stable user-facing error text
      pattern: spawn_session|invokeWithTimeout|toErrorMessage
    - from: src-tauri/src/commands/session.rs
      to: src-tauri/tests/multi_session_orchestration.rs
      via: integration test asserts failed launch returns explicit reason and preserves retry path
      pattern: spawn_session|Working directory|Failed to
---

<objective>
Close UAT launch-path gaps where users cannot progress past New Session, cannot create sessions, and receive no clear failure feedback.

Purpose: restore reliable session creation while preserving all locked Phase 5 interrupt/resume decisions and per-session lifecycle isolation.
Output: hardened New Session spawn path, explicit user-visible launch errors, and regression coverage preventing silent launch failures.
</objective>

<execution_context>
@/Users/timothyshortt/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/timothyshortt/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-session-lifecycle-control/05-CONTEXT.md
@.planning/phases/05-session-lifecycle-control/05-RESEARCH.md
@.planning/phases/05-session-lifecycle-control/05-session-lifecycle-control-01-SUMMARY.md
@.planning/phases/05-session-lifecycle-control/05-session-lifecycle-control-02-SUMMARY.md
@src/lib/stores/sessions.ts
@src/lib/components/NewSessionModal.svelte
@src-tauri/src/commands/session.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Diagnose and harden New Session launch command path</name>
  <files>src/lib/stores/sessions.ts, src-tauri/src/commands/session.rs, src-tauri/tests/multi_session_orchestration.rs</files>
  <action>Trace and fix the New Session launch path from frontend invoke to backend spawn so failures cannot silently stall the modal. Add a bounded timeout for `spawn_session` invocation in the frontend store, normalize all spawn failures into stable user-facing errors, and ensure retry-safe cleanup when launch fails mid-path. In backend `spawn_session`, preserve and propagate actionable error text (working dir validation, CLI spawn, worktree/session persistence) so UI surfaces concrete reasons. Keep existing Phase 5 interrupt/resume contracts untouched: do not alter interrupt confirmation copy, per-session operation gates, compact interrupt row feedback, or Interrupted status semantics.</action>
  <verify>npm run test:rust -- --test multi_session_orchestration</verify>
  <done>New Session launch either succeeds and returns a session id promptly or fails with explicit actionable error text; no indefinite submit state and no Phase 5 lifecycle regression.</done>
</task>

<task type="auto">
  <name>Task 2: Add explicit user-visible launch failure feedback in New Session modal</name>
  <files>src/lib/components/NewSessionModal.svelte, src/lib/stores/sessions.ts</files>
  <action>Update New Session modal UX so launch failures are impossible to miss. Render a clear inline error state tied to spawn failure reasons, keep entered form values for correction/retry, and guarantee submit controls recover from failure (no permanent disabled state). Ensure error copy is direct and user-actionable (for example invalid directory or CLI launch failure) instead of generic silent behavior. Preserve existing interrupt/resume UI behavior from Phase 5; this task is limited to New Session launch flow.</action>
  <verify>npm run test:unit -- NewSessionModal</verify>
  <done>When launch fails, user immediately sees readable failure feedback in the modal and can retry successfully without reopening the app.</done>
</task>

<task type="auto">
  <name>Task 3: Lock launch-path behavior with focused regression tests</name>
  <files>src/lib/components/NewSessionModal.test.ts, src/lib/__tests__/sessions.spawn.test.ts</files>
  <action>Add deterministic regression tests for New Session launch success, backend error propagation, timeout/error normalization, and post-failure retry behavior. Include a store-level test file for spawn-path error contracts and modal tests that assert visible error messaging (not console-only). Avoid flaky timing by mocking invoke responses and timeout boundaries explicitly.</action>
  <verify>npm run test:unit -- NewSessionModal sessions.spawn</verify>
  <done>Tests fail if New Session can stall without feedback, if launch errors are hidden/ambiguous, or if retry behavior regresses.</done>
</task>

</tasks>

<verification>
Run `npm run test:unit -- NewSessionModal sessions.spawn` and `npm run test:rust -- --test multi_session_orchestration` to confirm New Session launch failures are surfaced clearly and launch path remains stable.
</verification>

<success_criteria>
UAT gap is closed: users can create a new session from the New Session screen, and when launch fails the UI shows immediate clear error feedback with a working retry path while Phase 5 interrupt/resume locked decisions remain intact.
</success_criteria>

<output>
After completion, create `.planning/phases/05-session-lifecycle-control/05-session-lifecycle-control-03-SUMMARY.md`
</output>
