---
phase: 06-persistence-history
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/db/mod.rs
  - src-tauri/src/db/session.rs
  - src-tauri/src/commands/session.rs
  - src-tauri/src/lib.rs
  - src-tauri/src/session/projection.rs
  - src-tauri/tests/worktree_lifecycle.rs
  - src-tauri/tests/multi_session_orchestration.rs
autonomous: true
must_haves:
  truths:
    - Sessions reopened after app restart keep their last known status instead of being rewritten to failed during startup reconciliation.
    - Session history can be loaded after restart with a full ordered timeline (messages, thinking, tool calls/results, status, and errors).
    - Dashboard data returned from backend includes restore metadata needed for restored badges and recovery hints.
    - Event ordering remains deterministic across resume attempts so history replay does not collapse or reorder events.
  artifacts:
    - path: src-tauri/src/db/mod.rs
      provides: SQLite schema and migration guards for durable session event timeline and restored-session metadata columns.
    - path: src-tauri/src/db/session.rs
      provides: insert/list APIs for session history events plus startup restore reconciliation APIs that preserve last-known status.
    - path: src-tauri/src/commands/session.rs
      provides: runtime event persistence wiring, startup restore behavior, and `list_session_history` command.
    - path: src-tauri/src/session/projection.rs
      provides: dashboard projection fields for restored badge/recovery hint data.
    - path: src-tauri/tests/worktree_lifecycle.rs
      provides: startup reconciliation regression proving stale running/starting rows are restore-marked, not force-failed.
  key_links:
    - from: src-tauri/src/commands/session.rs
      to: src-tauri/src/db/session.rs
      via: event loop persists every canonical runtime event through a single DB history insert API
      pattern: insert_session_event|list_session_history
    - from: src-tauri/src/commands/session.rs
      to: src-tauri/src/session/projection.rs
      via: dashboard list projection includes restore metadata fields consumed by frontend badges and recovery hints
      pattern: project_dashboard_row|restored
    - from: src-tauri/src/commands/session.rs
      to: src-tauri/tests/worktree_lifecycle.rs
      via: startup reconciliation contract test locks preserve-last-known behavior
      pattern: reconcile_sessions_on_startup|restored
---

<objective>
Create the backend persistence and projection foundation for Phase 6 so restart restores are durable, history replay is complete, and the dashboard has restore metadata required by the locked UI behavior.

Purpose: satisfy SESS-04 and backend parts of OUT-02 while honoring locked restore decisions (preserve last-known status on reopen, no stale running->failed rewrite).
Output: SQLite session event timeline, restore-aware startup reconciliation, restore metadata in dashboard projection, and backend regression coverage.
</objective>

<execution_context>
@/Users/timothyshortt/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/timothyshortt/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-persistence-history/06-CONTEXT.md
@.planning/phases/06-persistence-history/06-RESEARCH.md
@.planning/phases/03-multi-session-orchestration/03-multi-session-orchestration-01-SUMMARY.md
@.planning/phases/05-session-lifecycle-control/05-session-lifecycle-control-01-SUMMARY.md
@src-tauri/src/db/mod.rs
@src-tauri/src/db/session.rs
@src-tauri/src/commands/session.rs
@src-tauri/src/session/projection.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add durable session event timeline schema and restore metadata persistence</name>
  <files>src-tauri/src/db/mod.rs, src-tauri/src/db/session.rs</files>
  <action>Add schema support for a durable `session_events` table that stores ordered event timeline rows with enough identity to avoid resume-attempt collisions (include session id, run id, seq, event type, payload JSON, timestamp, and deterministic unique/index constraints). Extend session dashboard row persistence with explicit restore metadata fields used by Phase 6 UI (`restored` flag plus restore timestamp or equivalent) and add migration guards for older DBs. Keep transaction behavior as `BEGIN IMMEDIATE` for write paths and avoid introducing any new dependency or storage engine per locked stack decisions.</action>
  <verify>npm run test:rust -- --test worktree_lifecycle</verify>
  <done>Database layer can persist/retrieve complete ordered history events and can persist restore markers on sessions without breaking existing session/message APIs.</done>
</task>

<task type="auto">
  <name>Task 2: Wire backend event persistence, restore reconciliation, and history command</name>
  <files>src-tauri/src/commands/session.rs, src-tauri/src/session/projection.rs, src-tauri/src/lib.rs, src-tauri/src/db/session.rs</files>
  <action>In the runtime event handling loop, persist every canonical `SessionEventPayload` variant to `session_events` before/with existing side effects so post-restart replay includes prompts/output/tool/status/error history instead of message-only history. Add a `list_session_history` Tauri command that returns ordered timeline rows for one session and register it in `src-tauri/src/lib.rs`. Replace startup stale-session reconciliation behavior so previous `starting|running` sessions keep last-known status and receive restore metadata/recovery-hint data instead of being rewritten to `failed`, explicitly honoring locked user decisions from `06-CONTEXT.md` even though earlier phase behavior force-failed stale rows.</action>
  <verify>npm run test:rust -- --test multi_session_orchestration</verify>
  <done>Backend exposes restore-aware dashboard projections plus a history API that returns a complete replayable timeline, and startup no longer force-fails stale in-flight rows.</done>
</task>

<task type="auto">
  <name>Task 3: Lock backend restore and timeline contracts with regressions</name>
  <files>src-tauri/tests/worktree_lifecycle.rs, src-tauri/tests/multi_session_orchestration.rs, src-tauri/src/commands/session.rs</files>
  <action>Add deterministic regression tests that fail if startup restore semantics regress to stale->failed rewriting, if restore metadata is missing from projected dashboard rows, or if session history ordering drops/duplicates events across resumed runs. Cover terminal and interrupted sessions to enforce the locked ranking parity for interrupted with other terminal states at the projection boundary.</action>
  <verify>npm run test:rust -- --test worktree_lifecycle --test multi_session_orchestration</verify>
  <done>Rust tests enforce Phase 6 backend contracts for preserve-last-known startup behavior, restore metadata projection, and durable ordered timeline replay.</done>
</task>

</tasks>

<verification>
Run `npm run test:rust -- --test worktree_lifecycle --test multi_session_orchestration` and verify all restore/timeline regressions pass.
</verification>

<success_criteria>
Phase 6 backend foundation is complete: restart reconciliation preserves last-known state with restore metadata, dashboard projection includes restore signals, and the app can query durable full-session event history after restart.
</success_criteria>

<output>
After completion, create `.planning/phases/06-persistence-history/06-persistence-history-01-SUMMARY.md`
</output>
