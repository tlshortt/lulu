---
phase: 03-multi-session-orchestration
plan: 04
type: execute
wave: 3
depends_on:
  - 03-01
  - 03-02
files_modified:
  - src-tauri/src/session/supervisor.rs
  - src-tauri/src/commands/session.rs
  - src-tauri/src/session/projection.rs
  - src-tauri/src/session/mod.rs
  - src-tauri/tests/multi_session_orchestration.rs
  - src-tauri/tests/worktree_lifecycle.rs
autonomous: true
gap_closure: true
must_haves:
  truths:
    - Backend dashboard rows returned to the app are projected through the locked projection boundary and always expose Starting, Running, Completed, or Failed
    - SessionSupervisor is the single owner of terminal persistence transitions so terminal writes are not duplicated in command orchestration
    - SessionSupervisor emits terminal status boundaries on session-event so dashboard/store listeners receive canonical terminal updates from one boundary
    - Failed dashboard rows continue to show one-line normalized reasons while non-failed rows do not expose failure text
  artifacts:
    - path: src-tauri/src/session/projection.rs
      provides: Runtime-used dashboard row projection helpers for status and failure normalization
    - path: src-tauri/src/commands/session.rs
      provides: Backend command path that exposes projected dashboard rows
    - path: src-tauri/src/session/supervisor.rs
      provides: Supervisor-owned terminal transition reducer (DB persistence + status event emission)
    - path: src-tauri/tests/multi_session_orchestration.rs
      provides: Regression coverage for supervisor-owned terminal boundaries and mixed-outcome isolation
  key_links:
    - from: src-tauri/src/commands/session.rs
      to: src-tauri/src/session/projection.rs
      via: list dashboard command maps DB rows through project_dashboard_row
      pattern: list_dashboard_sessions|project_dashboard_row
    - from: src-tauri/src/session/supervisor.rs
      to: src-tauri/src/db/session.rs
      via: supervisor terminal reducer performs transition_session_terminal/update_session_status
      pattern: transition_session_terminal|update_session_status|update_failure_reason
    - from: src-tauri/src/session/supervisor.rs
      to: session-event
      via: supervisor emits terminal status payloads after transition guard acceptance
      pattern: emit\("session-event"
---

<objective>
Close Phase 3 verification architecture gaps by wiring dashboard projection through backend command payloads and moving terminal status finalization ownership into SessionSupervisor.

Purpose: satisfy the remaining must-have key-links from verification so projection and terminal lifecycle boundaries match the intended architecture, not just user-visible behavior.
Output: supervisor-owned terminal reducer wiring, projected dashboard command payloads, and regression coverage proving the boundary contracts.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-session-orchestration/03-CONTEXT.md
@.planning/phases/03-multi-session-orchestration/03-multi-session-orchestration-VERIFICATION.md
@.planning/phases/03-multi-session-orchestration/03-multi-session-orchestration-01-SUMMARY.md
@.planning/phases/03-multi-session-orchestration/03-multi-session-orchestration-02-SUMMARY.md
@src-tauri/src/commands/session.rs
@src-tauri/src/session/supervisor.rs
@src-tauri/src/session/projection.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire backend dashboard list command through projection boundary</name>
  <files>src-tauri/src/commands/session.rs, src-tauri/src/session/projection.rs, src-tauri/src/session/mod.rs</files>
  <action>Add or update the dashboard list command path so backend dashboard payloads come from `db.list_dashboard_sessions()` mapped through `project_dashboard_row`, not ad hoc status/failure normalization in command code. Keep newest-first ordering from DB, preserve the locked status vocabulary (Starting/Running/Completed/Failed), and keep failure reason populated only for Failed rows. Do not introduce extra status variants, grouped sections, or progress fields in command payloads.</action>
  <verify>cd src-tauri && cargo test --test worktree_lifecycle projection_normalizes_dashboard_rows_to_locked_statuses</verify>
  <done>At least one runtime command path emits dashboard rows that are explicitly projected via `project_dashboard_row` and no longer leaves projection.rs orphaned from command/runtime usage.</done>
</task>

<task type="auto">
  <name>Task 2: Move terminal persistence and terminal status-event emission into SessionSupervisor</name>
  <files>src-tauri/src/session/supervisor.rs, src-tauri/src/commands/session.rs</files>
  <action>Create a supervisor-owned terminal finalization API that accepts session id, terminal status, sequence counter, and optional failure message, then performs guarded terminal transition persistence (`transition_session_terminal`/`update_session_status` + `update_last_activity`/`update_failure_reason`) and emits terminal `session-event` payloads from the supervisor boundary. Refactor command orchestration to delegate terminal completion/failure handling to this API so `finalize_session_once` no longer directly performs DB transition writes or terminal status-event emission. Keep compatibility `session-complete` and `session-error` behavior unchanged.</action>
  <verify>cd src-tauri && cargo test --test multi_session_orchestration supervisor_terminal_transition_applies_once_per_session</verify>
  <done>Terminal persistence transitions and terminal session-event emission happen through SessionSupervisor, with command code acting as caller/orchestrator rather than the reducer owner.</done>
</task>

<task type="auto">
  <name>Task 3: Add regression tests for projection wiring and supervisor-owned boundaries</name>
  <files>src-tauri/tests/multi_session_orchestration.rs, src-tauri/tests/worktree_lifecycle.rs, src-tauri/src/commands/session.rs</files>
  <action>Extend integration coverage to assert the two closed architecture links: projected dashboard command payloads use locked status/failure normalization and terminal transitions remain idempotent while terminal status events are emitted from the supervisor finalization path. Include a mixed-outcome scenario proving one failed session does not disrupt sibling sessions after refactor. Keep fixture timing deterministic and avoid brittle sleep-based assertions.</action>
  <verify>cd src-tauri && cargo test --test worktree_lifecycle --test multi_session_orchestration</verify>
  <done>Automated tests fail if projection boundary wiring is removed or if terminal reducer ownership drifts back into command-level direct DB/event writes.</done>
</task>

</tasks>

<verification>
Run `cd src-tauri && cargo test --test worktree_lifecycle --test multi_session_orchestration` and confirm projection boundary plus supervisor terminal ownership assertions pass.
</verification>

<success_criteria>
Verification gaps are closed: backend dashboard projection is runtime-wired through projection.rs, and SessionSupervisor is the architecture boundary for terminal persistence transitions and terminal status-event emission.
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-session-orchestration/03-multi-session-orchestration-04-SUMMARY.md`
</output>
