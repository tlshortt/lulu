---
phase: 01-foundation
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/db/mod.rs
  - src-tauri/src/db/session.rs
  - src-tauri/src/db/message.rs
  - src-tauri/src/lib.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "SQLite database can be created and opened"
    - "Sessions table exists with required columns"
    - "Concurrent write transactions work without locking"
  artifacts:
    - path: "src-tauri/src/db/mod.rs"
      provides: "Database initialization with WAL mode"
    - path: "src-tauri/src/db/session.rs"
      provides: "Session CRUD operations"
    - path: "lulu.db"
      provides: "SQLite database file"
  key_links:
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/db/mod.rs"
      via: "db::init_database()"
      pattern: "db::init_database"
---

<objective>
Implement SQLite database layer with proper concurrency handling for multi-session orchestration.

Purpose: Establish persistent storage for sessions and messages with WAL mode and proper write serialization.
Output: Database module with sessions table and basic CRUD operations.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-architecture/01-CONTEXT.md
@.planning/phases/01-foundation-architecture/01-RESEARCH.md
@.planning/phases/01-foundation-architecture/01-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rusqlite dependencies</name>
  <files>src-tauri/Cargo.toml</files>
  <action>
1. Add to src-tauri/Cargo.toml:
   ```toml
   [dependencies]
   rusqlite = { version = "0.31", features = ["bundled"] }
   serde = { version = "1.0", features = ["derive"] }
   serde_json = "1.0"
   tokio = { version = "1", features = ["sync"] }
   uuid = { version = "1.0", features = ["v4", "serde"] }
   chrono = { version = "0.4", features = ["serde"] }
   thiserror = "1.0"
   ```
2. Run `cargo check` in src-tauri to verify dependencies compile
  </action>
  <verify>Run `cd src-tauri && cargo check` - compiles without errors</verify>
  <done>All Rust dependencies resolve and compile</done>
</task>

<task type="auto">
  <name>Task 2: Create database module with WAL mode</name>
  <files>src-tauri/src/db/mod.rs, src-tauri/src/lib.rs</files>
  <action>
1. Create src-tauri/src/db/mod.rs:
   ```rust
   use rusqlite::{Connection, Result};
   use std::path::Path;
   use std::sync::Mutex;
   
   pub struct Database {
       pub conn: Mutex<Connection>,
   }
   
   pub fn init_database(db_path: &Path) -> Result<Database> {
       let conn = Connection::open(db_path)?;
       
       // WAL mode for concurrent reads
       // Synchronous NORMAL for better write performance
       // Busy timeout 5s to handle contention
       conn.execute_batch(
           "PRAGMA journal_mode=WAL;
            PRAGMA synchronous=NORMAL;
            PRAGMA busy_timeout=5000;
            PRAGMA foreign_keys=ON;"
       )?;
       
       // Create tables
       conn.execute_batch(
           "CREATE TABLE IF NOT EXISTS sessions (
               id TEXT PRIMARY KEY,
               name TEXT NOT NULL,
               status TEXT NOT NULL DEFAULT 'created',
               working_dir TEXT NOT NULL,
               created_at TEXT NOT NULL,
               updated_at TEXT NOT NULL
           );
           
           CREATE TABLE IF NOT EXISTS messages (
               id TEXT PRIMARY KEY,
               session_id TEXT NOT NULL,
               role TEXT NOT NULL,
               content TEXT NOT NULL,
               timestamp TEXT NOT NULL,
               FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
           );
           
           CREATE INDEX IF NOT EXISTS idx_messages_session_id ON messages(session_id);"
       )?;
       
       Ok(Database { conn: Mutex::new(conn) })
   }
   ```
2. Add error type in same file:
   ```rust
   #[derive(Debug, thiserror::Error)]
   pub enum DbError {
       #[error("Database error: {0}")]
       Sqlite(#[from] rusqlite::Error),
       #[error("Lock error")]
       Lock,
   }
   
   impl serde::Serialize for DbError {
       fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
       where S: serde::Serializer {
           serializer.serialize_str(&self.to_string())
       }
   }
   ```
 2. Wire database initialization in src-tauri/src/lib.rs:
    - On app startup (tauri::Builder::setup), build a db path in app data dir (e.g., app.path().app_data_dir().join("lulu.db")).
    - Call `db::init_database(&db_path)` and store the Database via `app.manage(db)`.
    - Return any init error to fail fast on startup.
  </action>
  <verify>Run `cd src-tauri && cargo check` - db module compiles and lib.rs builds</verify>
  <done>Database initializes with WAL mode at app startup and is managed as app state</done>
</task>

<task type="auto">
  <name>Task 3: Create session repository with transactions</name>
  <files>src-tauri/src/db/session.rs</files>
  <action>
1. Create src-tauri/src/db/session.rs:
   ```rust
   use crate::db::{Database, DbError};
   use rusqlite::params;
   use serde::{Deserialize, Serialize};
   use std::sync::Mutex;
   
   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct Session {
       pub id: String,
       pub name: String,
       pub status: String,
       pub working_dir: String,
       pub created_at: String,
       pub updated_at: String,
   }
   
   impl Database {
       pub fn create_session(&self, session: &Session) -> Result<(), DbError> {
           let conn = self.conn.lock().map_err(|_| DbError::Lock)?;
           
           // Use IMMEDIATE transaction for writes
           let tx = conn.transaction_with_behavior(
               rusqlite::TransactionBehavior::Immediate
           )?;
           
           tx.execute(
               "INSERT INTO sessions (id, name, status, working_dir, created_at, updated_at)
                VALUES (?1, ?2, ?3, ?4, ?5, ?6)",
               params![
                   session.id,
                   session.name,
                   session.status,
                   session.working_dir,
                   session.created_at,
                   session.updated_at,
               ],
           )?;
           
           tx.commit()?;
           Ok(())
       }
       
       pub fn get_session(&self, id: &str) -> Result<Option<Session>, DbError> {
           let conn = self.conn.lock().map_err(|_| DbError::Lock)?;
           
           let mut stmt = conn.prepare(
               "SELECT id, name, status, working_dir, created_at, updated_at 
                FROM sessions WHERE id = ?1"
           )?;
           
           let mut rows = stmt.query(params![id])?;
           
           if let Some(row) = rows.next()? {
               Ok(Some(Session {
                   id: row.get(0)?,
                   name: row.get(1)?,
                   status: row.get(2)?,
                   working_dir: row.get(3)?,
                   created_at: row.get(4)?,
                   updated_at: row.get(5)?,
               }))
           } else {
               Ok(None)
           }
       }
       
       pub fn list_sessions(&self) -> Result<Vec<Session>, DbError> {
           let conn = self.conn.lock().map_err(|_| DbError::Lock)?;
           
           let mut stmt = conn.prepare(
               "SELECT id, name, status, working_dir, created_at, updated_at 
                FROM sessions ORDER BY created_at DESC"
           )?;
           
           let rows = stmt.query_map([], |row| {
               Ok(Session {
                   id: row.get(0)?,
                   name: row.get(1)?,
                   status: row.get(2)?,
                   working_dir: row.get(3)?,
                   created_at: row.get(4)?,
                   updated_at: row.get(5)?,
               })
           })?;
           
           let mut sessions = Vec::new();
           for session in rows {
               sessions.push(session?);
           }
           
           Ok(sessions)
       }
       
       pub fn update_session_status(&self, id: &str, status: &str) -> Result<(), DbError> {
           let conn = self.conn.lock().map_err(|_| DbError::Lock)?;
           let tx = conn.transaction_with_behavior(
               rusqlite::TransactionBehavior::Immediate
           )?;
           
           let now = chrono::Utc::now().to_rfc3339();
           tx.execute(
               "UPDATE sessions SET status = ?1, updated_at = ?2 WHERE id = ?3",
               params![status, now, id],
           )?;
           
           tx.commit()?;
           Ok(())
       }
       
       pub fn delete_session(&self, id: &str) -> Result<(), DbError> {
           let conn = self.conn.lock().map_err(|_| DbError::Lock)?;
           let tx = conn.transaction_with_behavior(
               rusqlite::TransactionBehavior::Immediate
           )?;
           
           tx.execute("DELETE FROM messages WHERE session_id = ?1", params![id])?;
           tx.execute("DELETE FROM sessions WHERE id = ?1", params![id])?;
           
           tx.commit()?;
           Ok(())
       }
   }
   ```
2. Export module in db/mod.rs:
   ```rust
   pub mod session;
   pub use session::Session;
   ```
  </action>
  <verify>Run `cd src-tauri && cargo check` - session module compiles</verify>
  <done>Session CRUD operations work with IMMEDIATE transactions</done>
</task>

</tasks>

<verification>
- [ ] `cargo check` passes in src-tauri
- [ ] Database file created at app startup
- [ ] Sessions table created with correct schema
- [ ] WAL and SHM files created
- [ ] Can create, read, list, update, delete sessions
</verification>

<success_criteria>
SQLite database initialized with WAL mode, sessions table exists with required columns, concurrent write transactions work without SQLITE_BUSY errors.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-architecture/01-02-SUMMARY.md`
</output>
