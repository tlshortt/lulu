---
phase: 01-foundation
plan: "03"
type: execute
wave: 2
depends_on:
  - "01"
  - "02"
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/lib.rs
  - src-tauri/src/session/events.rs
  - src-tauri/src/session/mod.rs
  - src-tauri/src/session/cli.rs
  - src-tauri/src/session/manager.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/commands/session.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Claude CLI auto-detects path with optional user override fallback"
    - "Rust backend spawns Claude CLI in a single hardcoded working directory"
    - "CLI output parses into structured typed events (message/tool/thinking)"
    - "IPC streaming uses bounded channels and non-blocking emit to avoid backpressure"
    - "Sessions are never auto-killed; only user-initiated kill or app exit"
  artifacts:
    - path: "src-tauri/src/session/events.rs"
      provides: "Typed session event model for IPC"
    - path: "src-tauri/src/session/cli.rs"
      provides: "Claude CLI detection, capability probe, and spawning"
    - path: "src-tauri/src/session/manager.rs"
      provides: "Session lifecycle management"
    - path: "src-tauri/src/commands/session.rs"
      provides: "Tauri commands for session control and event emission"
  key_links:
    - from: "src-tauri/src/session/cli.rs"
      to: "src-tauri/src/session/events.rs"
      via: "parse_output_line"
      pattern: "SessionEvent"
    - from: "src-tauri/src/commands/session.rs"
      to: "Tauri events"
      via: "app.emit() from bounded channel"
      pattern: "mpsc::channel\(.*\).*app\\.emit"
---

<objective>
Implement Claude CLI subprocess spawning with structured IPC and bounded streaming channels.

Purpose: Enable Rust backend to spawn Claude Code process and stream structured events via Tauri.
Output: Session spawn with typed events, bounded IPC, and hardcoded working directory.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-architecture/01-CONTEXT.md
@.planning/phases/01-foundation-architecture/01-RESEARCH.md
@.planning/phases/01-foundation-architecture/01-01-PLAN.md
@.planning/phases/01-foundation-architecture/01-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IPC dependencies and typed session events</name>
  <files>src-tauri/Cargo.toml, src-tauri/src/session/events.rs, src-tauri/src/session/mod.rs</files>
  <action>
1. Update src-tauri/Cargo.toml dependencies:
   ```toml
   [dependencies]
   tokio = { version = "1", features = ["process", "io-util", "sync", "rt-multi-thread"] }
   tokio-util = { version = "0.7", features = ["codec", "io-util"] }
   which = "5.0"
   serde = { version = "1.0", features = ["derive"] }
   serde_json = "1.0"
   ```
2. Create src-tauri/src/session/events.rs with a tagged enum for IPC:
   - `SessionEvent` enum with variants: Message, ToolCall, ToolResult, Thinking, Status, Error.
   - Include `session_id`, `seq`, and `timestamp` in each payload for ordering.
   - Use `#[serde(tag = "type", content = "data")]` for ergonomic frontend parsing.
3. Update src-tauri/src/session/mod.rs to export `events` module and types.
  </action>
  <verify>Run `cd src-tauri && cargo check` - event module compiles</verify>
  <done>Typed session event model is available for IPC emission</done>
</task>

<task type="auto">
  <name>Task 2: Implement CLI detection with override + capability probing</name>
  <files>src-tauri/src/session/cli.rs</files>
  <action>
1. Extend ClaudeCli detection:
   - Add `find_with_override(override_path: Option<PathBuf>)` which validates override first, then PATH/common locations.
   - Return a clear error string when override path is invalid.
2. Add `detect_output_mode()` to probe JSON support:
   - Run `claude --help` or `claude --version` and check for `--json` flag support.
   - Return `OutputMode::Json` when supported, otherwise `OutputMode::Text`.
   - Record mode in the CLI struct to stabilize behavior across runs.
3. Enforce Phase 1 working directory constraint:
   - Define a single constant path (e.g., `~/.lulu/workdir`) and create it if missing.
   - Do NOT accept working_dir from UI in Phase 1.
4. Implement `spawn()` to return parsed `SessionEvent` values (not raw lines) and accept a `prompt: String` argument.
   - Write prompt to the child process stdin (preferred) to avoid shell escaping issues.
   - Use minimal CLI flags consistent with prior decisions; do NOT pass prompt as a CLI argument.
   - JSON-first parsing when output mode is Json.
   - Fallback text parsing that buffers message-level chunks (flush on blank line or end).
  </action>
  <verify>Run `cd src-tauri && cargo check` - CLI detection and probe compile</verify>
  <done>CLI auto-detects with override fallback, output mode is stable, working dir is hardcoded, and prompt is delivered via stdin</done>
</task>

<task type="auto">
  <name>Task 3: Wire bounded IPC streaming + session manager cleanup</name>
  <files>src-tauri/src/session/manager.rs, src-tauri/src/commands/session.rs, src-tauri/src/commands/mod.rs, src-tauri/src/lib.rs</files>
  <action>
1. Update SessionManager to track session handles and ensure kill_all on app close remains in lib.rs.
2. Do NOT add any auto-timeout or watchdog kill for unresponsive sessions in Phase 1; only user-initiated kill or app exit should terminate processes. Add a short comment in SessionManager to codify this decision.
3. In spawn_session command:
    - Accept `cli_path_override: Option<String>` and `prompt: String`; do NOT accept working_dir.
    - Pass the prompt to `cli.spawn(prompt, ...)` so the CLI receives it via stdin (no prompt in CLI args).
    - Create a bounded `tokio::sync::mpsc::channel` for `SessionEvent` (capacity 128).
    - Spawn reader tasks that parse CLI output and `try_send` into the channel (drop + emit Error on overflow).
    - Spawn a dedicated emitter task that reads from the channel and `app.emit("session-event", event)` to avoid blocking the reader tasks.
4. Emit Status events for start/complete/error to keep frontend state consistent.
   </action>
  <verify>Run `cd src-tauri && cargo check` - commands compile and use bounded channels</verify>
  <done>Structured events stream through bounded IPC without blocking CLI output readers, and no auto-kill logic is present</done>
</task>

</tasks>

<verification>
- [ ] `cargo check` passes in src-tauri
- [ ] Claude CLI auto-detects or uses override path
  - [ ] Session spawn command uses hardcoded working directory
  - [ ] Output streams as typed `session-event` payloads
  - [ ] Prompt is sent to Claude CLI via stdin (no prompt argument in CLI flags)
  - [ ] Bounded channel prevents IPC blocking under heavy output
  - [ ] All child processes killed on app close
  - [ ] No auto-timeout/auto-kill behavior exists for running sessions
</verification>

<success_criteria>
Rust backend can spawn Claude CLI process, stream structured events through bounded IPC without blocking, and clean up all child processes on app exit.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-architecture/01-03-SUMMARY.md`
</output>
