---
phase: 01-foundation
plan: "03"
type: execute
wave: 2
depends_on:
  - "01"
  - "02"
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/lib.rs
  - src-tauri/src/session/mod.rs
  - src-tauri/src/session/cli.rs
  - src-tauri/src/session/manager.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/commands/session.rs
  - src/lib/components/SessionOutput.svelte
  - src/lib/stores/sessions.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Rust backend can spawn Claude CLI process"
    - "Process output streams to Svelte frontend via Tauri events"
    - "Process can be killed on app exit"
  artifacts:
    - path: "src-tauri/src/session/cli.rs"
      provides: "Claude CLI detection and spawning"
    - path: "src-tauri/src/session/manager.rs"
      provides: "Session lifecycle management"
    - path: "src-tauri/src/commands/session.rs"
      provides: "Tauri commands for session control"
  key_links:
    - from: "src/routes/+page.svelte"
      to: "src-tauri/src/commands/session.rs"
      via: "invoke()"
      pattern: "invoke.*spawn_session"
    - from: "src-tauri/src/session/cli.rs"
      to: "Tauri events"
      via: "app.emit()"
      pattern: "app\\.emit"
---

<objective>
Implement Claude CLI subprocess spawning with basic IPC for streaming output to frontend.

Purpose: Enable Rust backend to spawn Claude Code process and stream output to Svelte UI via Tauri events.
Output: Working session spawn that shows Claude CLI output in UI.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-architecture/01-CONTEXT.md
@.planning/phases/01-foundation-architecture/01-RESEARCH.md
@.planning/phases/01-foundation-architecture/01-01-PLAN.md
@.planning/phases/01-foundation-architecture/01-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Tokio process dependencies</name>
  <files>src-tauri/Cargo.toml</files>
  <action>
1. Update src-tauri/Cargo.toml:
   ```toml
   [dependencies]
   tokio = { version = "1", features = ["process", "io-util", "sync", "rt-multi-thread"] }
   tokio-util = { version = "0.7", features = ["codec", "io-util"] }
   which = "5.0"
   ```
2. Run `cargo check` to verify
  </action>
  <verify>Run `cd src-tauri && cargo check` - Tokio process features compile</verify>
  <done>All Tokio dependencies resolve</done>
</task>

<task type="auto">
  <name>Task 2: Create CLI detection and spawner</name>
  <files>src-tauri/src/session/cli.rs</files>
  <action>
1. Create src-tauri/src/session/cli.rs:
   ```rust
   use std::path::PathBuf;
   use std::process::Stdio;
   use tokio::io::{AsyncBufReadExt, BufReader};
   use tokio::process::Command;
   use which::which;
   
   pub struct ClaudeCli {
       pub path: PathBuf,
   }
   
   impl ClaudeCli {
       /// Find Claude CLI in PATH or common locations
       pub fn find() -> Option<Self> {
           // Try PATH first
           if let Ok(path) = which("claude") {
               return Some(ClaudeCli { path });
           }
           
           // Try common locations
           let home = std::env::var("HOME").ok()?;
           let locations = [
               format!("{}/.claude/bin/claude", home),
               format!("{}/.local/bin/claude", home),
               "/usr/local/bin/claude".to_string(),
           ];
           
           for location in locations {
               let path = PathBuf::from(&location);
               if path.exists() {
                   return Some(ClaudeCli { path });
               }
           }
           
           None
       }
       
       /// Spawn Claude CLI with prompt, streaming output to callback
       pub async fn spawn<F>(self: &ClaudeCli, prompt: &str, working_dir: &str, mut on_output: F) -> Result<(), String>
       where
           F: FnMut(String) + Send + 'static,
       {
           let mut child = Command::new(&self.path)
               .arg("-p")
               .arg(prompt)
               .current_dir(working_dir)
               .stdout(Stdio::piped())
               .stderr(Stdio::piped())
               .stdin(Stdio::null())
               .spawn()
               .map_err(|e| format!("Failed to spawn: {}", e))?;
           
           let stdout = child.stdout.take().expect("stdout not captured");
           let stderr = child.stderr.take().expect("stderr not captured");
           
           // Stream stdout
           let stdout_reader = BufReader::new(stdout);
           let mut stdout_lines = stdout_reader.lines();
           
           // Stream stderr  
           let stderr_reader = BufReader::new(stderr);
           let mut stderr_lines = stderr_reader.lines();
           
           // Read both streams concurrently
           loop {
               tokio::select! {
                   line = stdout_lines.next_line() => {
                       match line {
                           Ok(Some(line)) => on_output(format!("[stdout] {}", line)),
                           Ok(None) => {},
                           Err(e) => on_output(format!("[stdout error] {}", e)),
                       }
                   }
                   line = stderr_lines.next_line() => {
                       match line {
                           Ok(Some(line)) => on_output(format!("[stderr] {}", line)),
                           Ok(None) => {},
                           Err(e) => on_output(format!("[stderr error] {}", e)),
                       }
                   }
                   status = child.wait() => {
                       match status {
                           Ok(status) => {
                               on_output(format!("[exited] {}", status));
                           }
                           Err(e) => {
                               on_output(format!("[wait error] {}", e));
                           }
                       }
                       break;
                   }
               }
           }
           
           Ok(())
       }
   }
   ```
  </action>
  <verify>Run `cd src-tauri && cargo check` - CLI module compiles</verify>
  <done>ClaudeCli can be detected and spawned with output streaming</done>
</task>

<task type="auto">
  <name>Task 3: Create session manager with cleanup</name>
  <files>src-tauri/src/session/manager.rs</files>
  <action>
  <action>
1. Create src-tauri/src/session/manager.rs:
   ```rust
   use crate::session::cli::ClaudeCli;
   use std::collections::HashMap;
   use std::sync::Arc;
   use tokio::sync::Mutex;
   
   pub struct SessionManager {
       pub sessions: Arc<Mutex<HashMap<String, SessionHandle>>>,
   }
   
   pub struct SessionHandle {
       pub id: String,
       pub name: String,
       pub child: tokio::process::Child,
       pub killed: Arc<Mutex<bool>>,
   }
   
   impl SessionManager {
       pub fn new() -> Self {
           SessionManager {
               sessions: Arc::new(Mutex::new(HashMap::new())),
           }
       }
       
       /// - Kill all running sessions call on app exit
       pub async fn kill_all(&self) {
           let mut sessions = self.sessions.lock().await;
           for (id, handle) in sessions.iter_mut() {
               let mut killed = handle.killed.lock().await;
               if !*killed {
                   let _ = handle.child.kill().await;
                   *killed = true;
               }
           }
           sessions.clear();
       }
   }
   
   impl Default for SessionManager {
       fn default() -> Self {
           Self::new()
       }
   }
   ```
2. Create src-tauri/src/session/mod.rs:
   ```rust
   pub mod cli;
   pub mod manager;
   
   pub use cli::ClaudeCli;
   pub use manager::SessionManager;
   ```
  </action>
  <verify>Run `cd src-tauri && cargo check` - manager compiles</verify>
  <done>SessionManager can track and kill all processes</done>
</task>

<task type="auto">
  <name>Task 4: Create Tauri commands for session control</name>
  <files>src-tauri/src/commands/session.rs</files>
  <action>
1. Create src-tauri/src/commands/session.rs:
   ```rust
   use crate::db::{Database, Session};
   use crate::session::{ClaudeCli, SessionManager};
   use tauri::{AppHandle, Emitter, State};
   use std::sync::Arc;
   use tokio::sync::Mutex;
   
   #[derive(Clone, serde::Serialize)]
   struct SessionOutput {
       session_id: String,
       line: String,
   }
   
   #[tauri::command]
   pub async fn spawn_session(
       app: AppHandle,
       db: State<'_, Database>,
       manager: State<'_, Arc<Mutex<SessionManager>>>,
       name: String,
       prompt: String,
       working_dir: String,
   ) -> Result<String, String> {
       // Find Claude CLI
       let cli = ClaudeCli::find().ok_or("Claude CLI not found")?;
       
       // Generate session ID
       let session_id = uuid::Uuid::new_v4().to_string();
       let now = chrono::Utc::now().to_rfc3339();
       
       // Create session record in database
       let session = Session {
           id: session_id.clone(),
           name: name.clone(),
           status: "running".to_string(),
           working_dir: working_dir.clone(),
           created_at: now.clone(),
           updated_at: now,
       };
       
       db.create_session(&session)
           .map_err(|e| format!("Failed to create session: {}", e))?;
       
       // Emit session started event
       app.emit("session-started", &session_id)
           .map_err(|e| e.to_string())?;
       
       // Spawn the CLI process
       let session_id_clone = session_id.clone();
       let app_clone = app.clone();
       
       tokio::spawn(async move {
           let result = cli.spawn(&prompt, &working_dir, move |line| {
               let _ = app_clone.emit("session-output", SessionOutput {
                   session_id: session_id_clone.clone(),
                   line,
               });
           }).await;
           
           match result {
               Ok(_) => {
                   let _ = app_clone.emit("session-complete", &session_id_clone);
               }
               Err(e) => {
                   let _ = app_clone.emit("session-error", (&session_id_clone, e));
               }
           }
       });
       
       Ok(session_id)
   }
   
   #[tauri::command]
   pub async fn list_sessions(
       db: State<'_, Database>,
   ) -> Result<Vec<Session>, String> {
       db.list_sessions()
           .map_err(|e| format!("Failed to list sessions: {}", e))
   }
   
   #[tauri::command]
   pub async fn get_session(
       db: State<'_, Database>,
       id: String,
   ) -> Result<Option<Session>, String> {
       db.get_session(&id)
           .map_err(|e| format!("Failed to get session: {}", e))
   }
   
   #[tauri::command]
   pub async fn kill_session(
       manager: State<'_, Arc<Mutex<SessionManager>>>,
       db: State<'_, Database>,
       id: String,
   ) -> Result<(), String> {
       // Mark as killed in database
       db.update_session_status(&id, "killed")
           .map_err(|e| e.to_string())?;
       
       // Kill the process if running
       let manager = manager.lock().await;
       let sessions = manager.sessions.lock().await;
       
       if let Some(handle) = sessions.get(&id) {
           let mut killed = handle.killed.lock().await;
           if !*killed {
               let _ = handle.child.kill().await;
               *killed = true;
           }
       }
       
       Ok(())
   }
   ```
2. Create src-tauri/src/commands/mod.rs:
   ```rust
   pub mod session;
   pub use session::*;
   ```
3. Update src-tauri/src/lib.rs to register commands and state:
   ```rust
   mod db;
   mod session;
   mod commands;
   
   use db::Database;
   use session::SessionManager;
   use std::sync::Arc;
   use tokio::sync::Mutex;
   
   #[cfg_attr(mobile, tauri::mobile_entry_point)]
   pub fn run() {
       let db = Database::init_database(std::path::Path::new("lulu.db"))
           .expect("Failed to initialize database");
       
       let session_manager = Arc::new(Mutex::new(SessionManager::new()));
       
       tauri::Builder::default()
           .manage(db)
           .manage(session_manager)
           .invoke_handler(tauri::generate_handler![
               commands::spawn_session,
               commands::list_sessions,
               commands::get_session,
               commands::kill_session,
           ])
           .on_window_event(|window, event| {
               if let tauri::WindowEvent::CloseRequested { .. } = event {
                   let app = window.app_handle();
                   if let Some(state) = app.try_state::<Arc<Mutex<SessionManager>>>() {
                       let runtime = tokio::runtime::Runtime::new().unwrap();
                       runtime.block_on(async {
                           let manager = state.lock().await;
                           manager.kill_all().await;
                       });
                   }
               }
           })
           .run(tauri::generate_context!())
           .expect("error while running tauri application");
   }
   ```
  </action>
  <verify>Run `cd src-tauri && cargo check` - commands compile</verify>
  <done>Tauri commands for session spawn, list, get, kill all work</done>
</task>

<task type="auto">
  <name>Task 5: Create Svelte frontend to display session output</name>
  <files>src/lib/stores/sessions.ts, src/lib/components/SessionList.svelte, src/lib/components/SessionOutput.svelte</files>
  <action>
1. Create src/lib/stores/sessions.ts:
   ```typescript
   import { invoke } from '@tauri-apps/api/core';
   import { listen } from '@tauri-apps/api/event';
   
   export interface Session {
       id: string;
       name: string;
       status: string;
       working_dir: string;
       created_at: string;
       updated_at: string;
   }
   
   export interface SessionOutput {
       session_id: string;
       line: string;
   }
   
   export const sessions = $state<Session[]>([]);
   export const sessionOutputs = $state<Record<string, string>>({});
   
   export async function loadSessions() {
       sessions = await invoke('list_sessions');
   }
   
   export async function spawnSession(name: string, prompt: string, workingDir: string) {
       const id = await invoke<string>('spawn_session', {
           name,
           prompt,
           workingDir
       });
       await loadSessions();
       return id;
   }
   
   export async function initSessionListeners() {
       await listen<SessionOutput>('session-output', (event) => {
           const { session_id, line } = event.payload;
           if (!sessionOutputs[session_id]) {
               sessionOutputs[session_id] = '';
           }
           sessionOutputs[session_id] += line + '\n';
       });
       
       await listen<string>('session-complete', async (event) => {
           await loadSessions();
       });
       
       await listen<string>('session-error', async (event) => {
           await loadSessions();
       });
   }
   ```
   
2. Update src/routes/+page.svelte to use sessions:
   ```svelte
   <script lang="ts">
     import Sidebar from '$lib/components/Sidebar.svelte';
     import MainArea from '$lib/components/MainArea.svelte';
     import { onMount } from 'svelte';
     import { initSessionListeners, loadSessions } from '$lib/stores/sessions';
     
     onMount(async () => {
       await initSessionListeners();
       await loadSessions();
     });
   </script>
   
   <div class="flex h-screen bg-background">
     <Sidebar />
     <MainArea />
   </div>
   ```
  </action>
  <verify>Build with `npm run tauri build` - compiles successfully</verify>
  <done>Frontend displays session list and output from CLI</done>
</task>

</tasks>

<verification>
- [ ] `cargo check` passes in src-tauri
- [ ] Claude CLI can be found on system
- [ ] Session spawn command creates database record
- [ ] Output streams to frontend via Tauri events
- [ ] All child processes killed on app close
</verification>

<success_criteria>
Rust backend can spawn Claude CLI process, process output streams to Svelte frontend via Tauri events, and all processes are cleaned up on app exit.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-architecture/01-03-SUMMARY.md`
</output>
