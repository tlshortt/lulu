---
phase: 01-foundation-architecture
plan: "08"
type: execute
wave: 4
depends_on:
  - "05"
  - "07"
files_modified:
  - src-tauri/src/commands/session.rs
  - src-tauri/src/session/cli.rs
  - src-tauri/src/session/events.rs
  - src-tauri/tests/cli_ipc.rs
  - src-tauri/tests/runtime_startup.rs
  - src/lib/stores/sessions.ts
  - src/lib/__tests__/sessions.isolation.test.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Session runtime uses bounded, non-blocking event transport from CLI parsing to Tauri emits"
    - "CLI compatibility is explicitly validated before spawn and failures are surfaced as deterministic session errors"
    - "Session event streams stay isolated by session_id under interleaved output"
    - "Foundation runtime has reproducible launch and SQLite startup evidence"
  artifacts:
    - path: "src-tauri/src/commands/session.rs"
      provides: "Bounded channel bridge from spawned CLI events to Tauri app.emit"
      min_lines: 140
    - path: "src-tauri/src/session/cli.rs"
      provides: "CLI compatibility guardrails and event parsing in subprocess layer"
      min_lines: 220
    - path: "src-tauri/tests/runtime_startup.rs"
      provides: "Automated runtime startup checks for SQLite initialization and app-ready prerequisites"
      exports: ["startup_creates_database_file", "startup_schema_is_queryable"]
    - path: "src/lib/__tests__/sessions.isolation.test.ts"
      provides: "Frontend proof that interleaved events do not cross session boundaries"
  key_links:
    - from: "src-tauri/src/commands/session.rs"
      to: "src-tauri/src/session/cli.rs"
      via: "spawn_with_events over tokio mpsc::channel"
      pattern: "spawn_with_events"
    - from: "src-tauri/src/commands/session.rs"
      to: "Tauri event bus"
      via: "dedicated emitter task calling app.emit('session-event', ...)"
      pattern: "emit\(\"session-event\""
    - from: "src/lib/stores/sessions.ts"
      to: "src/lib/__tests__/sessions.isolation.test.ts"
      via: "routeSessionEvent and message buffer behavior"
      pattern: "session_id"
---

<objective>
Close the remaining Phase 1 verification gaps by hardening the production event pipeline and adding executable runtime evidence.

Purpose: Ensure the foundation is operationally safe under load and verifiable without relying on implicit assumptions.
Output: Bounded IPC/event transport, CLI compatibility checks, isolation tests, and startup verification coverage.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-architecture/01-CONTEXT.md
@.planning/phases/01-foundation-architecture/01-RESEARCH.md
@.planning/phases/01-foundation-architecture/01-05-SUMMARY.md
@.planning/phases/01-foundation-architecture/01-07-SUMMARY.md
@.planning/phases/01-foundation-architecture/01-VERIFICATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement bounded non-blocking runtime event transport</name>
  <files>src-tauri/src/commands/session.rs, src-tauri/src/session/cli.rs, src-tauri/src/session/events.rs</files>
  <action>
1. Update `spawn_session` runtime wiring to use `ClaudeCli::spawn_with_events` (typed events) as the production path instead of line-callback output.
2. Create a bounded Tokio channel per spawned session (fixed capacity, e.g., 256) and a dedicated emitter task in `commands/session.rs` that forwards events to `app.emit("session-event", ...)`.
3. Ensure backpressure behavior is explicit and non-blocking: when producer send would block/full, emit a deterministic overflow/error status for that session rather than stalling command execution.
4. Preserve legacy compatibility events (`session-output`, `session-complete`, `session-error`) while keeping `session-event` as canonical.
5. Keep event ownership in command layer (not `app.emit` inside `cli.rs`) and document this in code-level type/function naming so architecture intent is unambiguous.
  </action>
  <verify>Run `cd src-tauri && cargo test --test cli_ipc` and confirm event ordering still passes through the bounded pipeline</verify>
  <done>Runtime path emits typed events through a bounded channel bridge without blocking on high output volume</done>
</task>

<task type="auto">
  <name>Task 2: Add CLI compatibility guardrails and session isolation tests</name>
  <files>src-tauri/src/session/cli.rs, src-tauri/tests/cli_ipc.rs, src/lib/stores/sessions.ts, src/lib/__tests__/sessions.isolation.test.ts</files>
  <action>
1. Add explicit CLI compatibility validation in `cli.rs` (version probe + supported range check) and return deterministic error messages when incompatible.
2. Keep behavior aligned with the pinned-version decision from project state: fail fast for known-unsupported versions, and provide a clear message for unknown parse modes.
3. Extend Rust integration coverage in `src-tauri/tests/cli_ipc.rs` to assert compatibility checks are enforced and surfaced through session error/status events.
4. Add a frontend unit test (`sessions.isolation.test.ts`) that feeds interleaved events for multiple `session_id` values and proves message buffers and event arrays never cross sessions.
5. Update store logic only as needed to satisfy isolation assertions; avoid introducing global/shared buffer behavior.
  </action>
  <verify>Run `cd src-tauri && cargo test --test cli_ipc` and `npm run test:unit -- sessions.isolation`</verify>
  <done>Incompatible CLI versions are rejected predictably and interleaved streams remain isolated per session_id end-to-end</done>
</task>

<task type="auto">
  <name>Task 3: Add startup verification coverage for launchability and SQLite creation</name>
  <files>src-tauri/tests/runtime_startup.rs, package.json</files>
  <action>
1. Add `src-tauri/tests/runtime_startup.rs` with integration tests that create a temp app-data directory, initialize the database via production init code, and assert `lulu.db` is created and queryable.
2. Include assertions for required startup invariants (schema exists, sessions table accessible) so DB-open evidence is executable, not narrative.
3. Add a package script that runs the Phase 1 startup verification path in one command (Rust integration tests plus existing relevant frontend checks).
4. Keep evidence reproducible in CI/local environments without requiring checked-in binaries.
  </action>
  <verify>Run the new package script and confirm all startup/runtime checks pass</verify>
  <done>Phase 1 has executable verification evidence for startup and SQLite creation/open behavior</done>
</task>

</tasks>

<verification>
- [ ] `cargo test --test cli_ipc` validates bounded event flow, ordering, and compatibility handling
- [ ] `cargo test --test runtime_startup` validates `lulu.db` creation and schema accessibility
- [ ] `npm run test:unit -- sessions.isolation` proves session_id isolation in frontend event buffering
</verification>

<success_criteria>
Remaining Phase 1 verification gaps are closed: production event transport is bounded and non-blocking, compatibility guardrails are explicit, session streams are isolated, and startup/SQLite behavior is reproducibly verifiable.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-architecture/01-08-SUMMARY.md`
</output>
